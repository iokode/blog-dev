---
title: Algunas medidas de seguridad que deber√≠as de tomar al desarrollar una aplicaci√≥n
slug: algunas-medidas-de-seguridad-que-deberias-de-tomar-al-desarrollar-una-aplicacion
author: montyclt
publishDate: 2022-06-05
license: cc-by-4
discussionId: 16
tags:
 - web
 - security
---

Hace unos d√≠as mantuve una conversaci√≥n por tel√©fono con [Sergio](https://twitter.com/sergiobarriel), en la que me pregunt√≥ sobre qu√© medidas de ciberseguridad tomo durante el desarrollo de software. Le respond√≠ por tel√©fono como pude, pero me parece interesante ampliar por aqu√≠ la informaci√≥n que pude darle, as√≠ como hacerla p√∫blica para que lo pueda leer toda persona a la que esto le pueda ser √∫til.

Lo primero que le dije, y creo que es muy importante se√±alar, es que **yo no soy un experto en ciberseguridad** y que, aunque me lo tomo muy en serio, **jam√°s podr√≠a asegurar que mis aplicaciones son 100% seguras** y que nadie encontrar√° nunca una vulnerabilidad. Hacer esta afirmaci√≥n, aparte de mentir, s√≥lo demostrar√≠a arrogancia por mi parte.

Una vez dicho esto, en esta entrada voy a enumerar y explicar aquellas medidas de seguridad que suelo tener en cuanta cuando desarrollo software.


## Medidas generales
Estas son una series de medidas, que podr√≠an aplicarse a cualquier tipo de aplicaci√≥n.

### No _hardcodear_ informaci√≥n sensible en el c√≥digo.
Esto es simple, no escribir directamente en el c√≥digo ning√∫n tipo de informaci√≥n sensible como credenciales o tokens de autenticaci√≥n.

Aunque distribuyas una aplicaci√≥n en forma de binarios, hay herramientas con las que es relativamente sencillo descompilarlo y acceder al c√≥digo. Si escribes informaci√≥n sensible en un string, cualquiera con acceso a los binarios podr√≠a descompilarla y extraerla (y eso sin hablar de los lenguajes interpretados donde directamente ejecutas un fichero de texto con el c√≥digo).

Escribirlas en un comentario tampoco es una opci√≥n, pues, aunque se van a perder durante la compilaci√≥n, el c√≥digo original sigue existiendo y podr√≠a filtrarse. Si crees que esto es casi imposible porque tendr√≠an que acceder a tus servidores privados y descargar el c√≥digo, debes de saber que a Micrososft se le filtr√≥ el c√≥digo de Windows XP.

### Mantener los ficheros de configuraci√≥n que tienen informaci√≥n sensible fuera del directorio de desarrollo.
No he sido el primero, ni ser√© el √∫ltimo al que le ha pasado esto, pero he de admitir que me ha ocurrido. He subido a GitHub un fichero de configuraci√≥n que tiene tokens de acceso a servicios que usa mi aplicaci√≥n. Cuando esto ocurre, es una odisea eliminarlos, pues Git mantiene un historial de cambios en el tiempo, y no basta con a√±adir un commit nuevo que elimine el fichero. Es importante por lo tanto evitar subir ficheros de configuraci√≥n con informaci√≥n sensible a un sistema de control de versiones, incluso en repositorios privados.

Aunque es bastante com√∫n encontrar como soluci√≥n a esto, simplemente mantener el fichero de configuraci√≥n ignorado, en mi opini√≥n no es suficiente. Tambi√©n deber√≠a de estar lejos de los ficheros de c√≥digo (es decir, fuera del directorio del proyecto), dado que, aunque est√© ignorado, es f√°cil por error equivocarse y forzar su commit.

Por suerte para los desarrolladores .NET, Microsoft nos provee un soluci√≥n bastante c√≥moda llamada user-secrets, que consiste en mantener los ficheros de secretos en el directorio personal (`%APPDATA%\Microsoft\UserSecrets\` en Windows, `~/.microsoft/usersecrets/` en Linux y macOS).

### Cifrar el tr√°fico con SSL
Cuando desarrollo una aplicaci√≥n que se comunica con otras mediante alg√∫n mecanismo como pueden ser sockets TCP, intento que el tr√°fico vaya cifrado mediante un sistema de cifrado asim√©trico. Generalmente suelo utilizar certificados X.509 para ello.


## Medidas en aplicaciones web
Existen ciertas vulnerabilidades conocidas que podr√≠as introducir en tu aplicaci√≥n web. Veamos algunas de ellas y c√≥mo mitigarlas.

### Utilizar siempre HTTPS
Esto es algo muy b√°sico, pero siempre que se desarrolla una aplicaci√≥n web, se debe de configurar el servidor para que utilice HTTPS. Esto permite que todo el tr√°fico entre el servidor web y el navegador vaya cifrado, √∫til para evitar que un tercero pueda interceptar datos, como por ejemplo los introducidos en un formulario.

Otra ventaja de utilizar HTTPS, es que permite al navegador autenticar al servidor mediante firma digital, por lo que si posee un certificado emitido para Microsoft, podemos estar bastante seguros de que el sitio web pertenece a Microsoft (comprobar el nombre de dominio por s√≠ s√≥lo no es suficiente, ya que pueden haber envenenado el servidor DNS).

### Cifrar todas las cookies
Las cookies generalmente almacenan datos que nos son √∫tiles en el servidor, sin embargo, el usuario podr√≠a modificarlas manualmente en su navegador, afectando as√≠ al funcionamiento esperado de la aplicaci√≥n web.

Cifrar las cookies en el servidor, y descifrarlas al recibirlas, nos permite protegernos de que un usuario malintencionado no las modifica, ya que para ello tendr√≠a que ser capaz de descifrarla, hacer la modificaci√≥n y volver a modificarla, algo que en principio no deber√≠a de poder hacer porque la clave de cifrado no deber√≠a de salir del servidor.

Algunos frameworks de desarrollo web como [Laravel](https://laravel.com) permiten cifrar todas las cookies antes de ser enviadas, por lo que una vez configurado, no tendr√°s que preocuparte de hacerlo en cada punto que la aplicaci√≥n haga set de una cookie.

### Protecci√≥n contra ataques XSS
Un ataque XSS es un tipo de ataque que permite a un usuario inyectar c√≥digo (generalmente JavaScript) en un sitio web que no es de su propiedad. Veamos un ejemplo. Imagina el siguiente fragmento de c√≥digo PHP, esto podr√≠a ser un foro o la zona de comentarios de un blog:
```php
<?php
$comments = get_comments_from_database();
?>

<div class="comments">
    <?php foreach ($comments as $comment) { ?>
        <div class="comment">
            <p><?= $comment ?></p>
        </div>
    <?php } ?>
</div>

<form method="post" action="insert-comment.php">
    <label for="comment-content">Contenido del comentario</label>
    <textarea id="comment-content" name="comment-content"></textarea>
    <button type="submit">Enviar comentario</button>
</form>
```

El c√≥digo del fichero `insert-comment.php` ser√≠a algo as√≠:
```php
<?php
$comment = $_POST["comment-content"];
save_comment_into_database($comment);
```

Se esperar√≠a que un usuario introdujese un comentario y lo enviase, este se guardar√≠a en la base de datos, y se adjuntar√≠a al HTML para mostrarlo en la lista de comentarios. Esto es, si un usuario escribiese "Hola, esto me parece muy interesante", el HTML que se generar√≠a ser√≠a algo como esto:

```html
<div class="comments">
    <div class="comment">
        <p>Comentario anterior</p>
    </div>
    <div class="comment">
        <p>Hola, esto me parece muy interesante</p>
    </div>
</div>
```

Pero... ¬øqu√© ocurrir√≠a si un usuario escribiese lo siguiente en el textarea?
```
<script>window.location.replace("http://evil.example.com");</script>
```
El HTML generado ser√≠a el siguiente:
```html
<div class="comments">
    <div class="comment">
        <p>Comentario anterior</p>
    </div>
    <div class="comment">
        <p><script>window.location.replace("http://evil.example.com");</script></p>
    </div>
</div>
```
Esto har√≠a que a partir del momento en el que se envi√≥ ese comentario, al acceder al listado de comentarios, el navegador ejecutar√≠a el c√≥digo JavaScript y por lo tanto redireccionar√≠a al sitio web malicioso `evil.example.com`.

La forma de evitar este ataque es comprobar siempre los datos que ha introducido el usuario, y dependiendo del contexto de la aplicaci√≥n, eliminar de esos datos cualquier parte de c√≥digo susceptible a ser interpretado. Muchos frameworks de desarrollo web incorporan herramientas que limpian los datos antes de colocarlos en los una vista. Por ejemplo, en [ASP.NET Core](https://dotnet.microsoft.com/en-us/apps/aspnet), el sistema de plantillas Razor por defecto limpia cualquier entidad HTML antes de colocarlas en una vista, a no ser que se le especifique expl√≠citamente que no lo haga con el m√©todo `Html.Raw`.

### Evitar robo de cookies
El robo de cookies (secuestro de sesi√≥n) consiste en robar una cookie de un navegador para ser introducida en otro navegador controlado por un atacante. Hay varias formas de robar las cookies, siendo un ataque XSS que accede a la cookie a trav√©s de JavaScript una de las m√°s comunes. Hay otras formas de robar cookies, no utilizar HTTPS habilitar√≠a a cualquiera que escuche el tr√°fico hacerse con las cookies, un malware instalado en el navegador que env√≠e a un atacante las cookies establecidas.

Cifrar una cookie por s√≠ mismo no evitar√≠a el secuestro de cookies, y evitarlo completamente es complicado. Aqu√≠ puedo dar una serie de recomendaciones:
- Establece el tiempo de vida de las cookies al menor posible. Haz que el servidor las rechace una vez superado el TTL.
- Establece siempre los atributos `Secure` y `HttpOnly`. El primero indica al navegador que no env√≠e las cookies si no es por HTTPS y el segundo que no sean accesible desde scripts en el cliente.
- Intenta asociar alg√∫n dato extra a la sesi√≥n como el User-Agent o la direcci√≥n IP. Si la petici√≥n proviene con una misma cookie de sesi√≥n, pero un navegador distinto, entonces cierra esa sesi√≥n desde el servidor.


### Nunca cambiar el estado el estado con peticiones GET
Es algo bastante habitual ver en aplicaciones webs que hay rutas que con una simple petici√≥n GET, estas realizan alguna acci√≥n que afectan al estado. Quiz√°s el caso m√°s com√∫n sea que al visitar /logout, esta cierra la sesi√≥n del usuario. El problema de esto, es que un sitio externo podr√≠a enviar una petici√≥n GET desde tu navegador a la ruta (con un simple `<img src="example.com/logout" />` por ejemplo).

Esto es lo que se conoce como un ataque CSRF (o XSRF), y para evitar esto, todas las peticiones que hagan un cambio sobre el estado, deber√≠an de tener un verbo diferente a GET o HEAD. POST suele ser una buena elecci√≥n por la compatibilidad con los formularios.

### Verificar tokens CSRF
Usar rutas POST para hacer acciones que afecten al estado de la aplicaci√≥n, puede ayudar a mitigar algunos ataques CSRF simples como el mencionado anteriormente, pero no es suficiente ya que el ataque anterior podr√≠a realizarse con que simplemente la web atacante tenga algo similar a esto:

```html
<form type="post" action="example.com/logout">
    <button type="submit">Pulsa aqu√≠ para continuar</button>
</form>
```

Para evitar esto, se suelen utilizar tokens CSRF, que no es m√°s que un token que si no va incluido en la petici√≥n POST, esta no ser√° procesada. Pr√°cticamente cualquier framework de desarrollo web suele llevar resuelta la generaci√≥n y verificaci√≥n de tokens CSRF y middleware para comprobarlos antes de procesar una petici√≥n diferente a GET o HEAD.

Si por cualquier motivo no est√°s utilizando un framework de desarrollo web, ser√≠a tan sencillo como generar un string aleatorio, asociarlo a la sesi√≥n e incluirlo en todos los formularios como un `<input type=‚Äùhidden‚Äù />`. Cuando vayas a procesar peticiones POST, verificar que el token est√° presente y corresponde con el token guardado en la sesi√≥n.


## Medidas en aplicaciones que acceden a datos
Cuando se acceden a datos provenientes de una fuente externa, tambi√©n es posible dejar alguna vulnerabilidad altamente conocida.

### No construir quieries con datos que provienen de fuentes externas.
Es algo com√∫n encontrar aplicaciones que utilizan datos que provienen de una fuente externa, y para acceder ellos construyen expresiones que representan que datos debe de traer de la fuente externa (lo que com√∫nmente se conoce como una query).

Por requisito de muchas de estas aplicaciones, hay veces que la expresi√≥n construida depende de datos de entrada, por ejemplo, digamos que tu aplicaci√≥n requiere obtener todos los datos relativos al primer cliente cuyo apellido sea introducido por el usuario. Para lograr eso, la aplicaci√≥n podr√≠a construir una query similar a esta:

```cs
string familyName = PromptUser("What is the family name?");
string query = "from customers where family_name equals '" + familyName + "' get first";
var result = RunQuery(query);
```

El problema de esto es que un usuario malicioso podr√≠a de forma relativamente sencilla alterar la query introduciendo algo similar a esto en el prompt `a' or is_admin equals '1`, haciendo que la query construida finalmente sea `from customers where family_name equals 'a' or is_admin equals '1' get first`, por lo que la aplicaci√≥n obtendr√≠a los datos del primer usuario administrador.

La forma m√°s sencilla de solucionar este problema es evitar construir queries con datos que provienen de una fuente externa (no √∫nicamente la entrada del usuario). De esta forma la query nunca se modifica con los datos que ha introducido el usuario, y estos se env√≠an al proveedor de datos en forma de par√°metros. El resultado ser√≠a algo similar a esto:

```cs
string familyName = PromptUser("What is the family name?");
string query = "from customers where family_name equals '?' get first";
var result = RunQuery(query, familyName);
```

Est√° bastante extendido tomar estas medidas de seguridad cuando se construyen queries SQL, sin embargo, esto no es un problema en s√≠ de SQL, si no que podr√≠a ser una vulnerabilidad siempre que se construyan queries con datos que vienen desde fuentes que no controlamos, y por desgracia no es tan com√∫n verlo aplicado a otros tipos de queries. He visto casos de inyecci√≥n tanto en queries GraphQL como en MongoDB.

### Cifra aquella informaci√≥n sensible
Cuando almacenes en la base de datos informaci√≥n sensible como contrase√±as o n√∫meros de tarjeta, cifra esta informaci√≥n de forma que si se filtra el contendido de la base de datos, el impacto sobre datos sensibles sea el menor posible. Recomendar√≠a hacer esto directamente desde la aplicaci√≥n, pero hay algunos [DBMS](https://iokode.blog/post/2022/por-que-usar-una-base-de-datos) como RavenDB que permiten cifrar toda la base de datos entera, siendo este cifrado trasparente a la aplicaci√≥n.


## Medidas en aplicaciones que almacenan credenciales de usuarios

### Delega la autenticaci√≥n
Si tu aplicaci√≥n no requiere que t√∫ almacenes los usuarios, si no que te sirve con simplemente poder diferenciarlos, a√±ade los botones de "Login with Google", "Login with Apple" y olvidate de gestionar t√∫ la autenticaci√≥n. Esto no es posible en todo tipo de aplicaciones, dado que puedes necesitar usuarios que no tengan cuenta en estos proveedores, ser una aplicaci√≥n sin acceso a Internet, etc., pero si es posible hacerlo, te ahorrar√°s trabajo y problemas.

### Hashea las contrase√±as
Esto es lo mismo que he expuesto arriba sobre cifrar la informaci√≥n sensible que guardes en las bases de datos. Sin embargo, con las contrase√±as podemos ir un paso m√°s all√° y deber√≠amos de guardar un hash (cifrado) en vez de la contrase√±a en s√≠. Con las contrase√±as nunca interesa leerla, si no comprobar que es correcta, y esto se puede guardando √∫nicamente un hash. Cuando el usuario introduce su contrase√±a, esta se hashear√° y se comparar√°n los hashes. De esta forma, evitas que ante un robo y descifrado de la base de datos, no podr√° acceder a las contrase√±as.

Por favor, utiliza algoritmos de hash dise√±ados espec√≠ficamente para contrase√±as y no MD5 o SHA-1. El algoritmo bcrypt puede ser una buena opci√≥n.

Si vas a incluir un [salt](https://es.wikipedia.org/wiki/Sal_(criptograf%C3%ADa)) en el hashing, como ya hemos dicho arriba, no lo hardcodees (aunque bcrypt ya incluye salt por defecto, por lo que no ser√≠a necesario a√±adirlo manualmente).


## Algunas estrategias de mitigaci√≥n
Como podemos observar, la seguridad es algo muy complicado, pues en pr√°cticamente cualquier punto de tu aplicaci√≥n podr√≠as estar introduciendo una vulnerabilidad sin darte cuenta. Es muy dif√≠cil estar al tanto de todos los factores.

### Conoce las vulnerabilidades m√°s comunes
Para reducir el n√∫mero de vulnerabilidades que puedes introducir en tu aplicaci√≥n, es importante conocer las m√°s comunes. Esta entrada podr√≠a ser un buen comienzo de algunas de las vulnerabilidades m√°s conocidas, pero en Internet hay cientos de p√°ginas con informaci√≥n m√°s ampliada sobre cientos de vulnerabilidades comunes. Invertir algo de tiempo en investigarlas y comprobar que no se te haya colado alguna en tu aplicaci√≥n suele ser una buena pr√°ctica.

### _Piensa como un atacante_
Otra idea para intentar mitigar las vulnerabilidades, es _pensar como un atacante_. Pongamos un ejemplo:

Imagina una aplicaci√≥n de escritorio de chat en la que tienes un bot√≥n de recordar usuario y contrase√±a.

![Captura del antiguo Windows Live! Messenger con la opci√≥n de recordar contrase√±a marcada.](windows-live-messenger-screenshot.jpg)

Esta aplicaci√≥n guarda las credenciales en un fichero cifrado de forma que si es examinado no pueda ser le√≠do. La aplicaci√≥n cuando se abre descifra el fichero y almacena esas credenciales en memoria. Quiz√°s simplemente podr√≠a hacer un dump de la memoria de la aplicaci√≥n para extraer las credenciales en plano...

¬øC√≥mo podr√≠a evitar esto?

### Auditor√≠a de ciberseguridad
Existen empresas especializadas en la b√∫squeda de vulnerabilidades, que emplean equipos de personas especializados en vulnerabilidades y con personal que _piensa como un atacante_. Si est√°s desarrollando un proyecto suficientemente importante, quiz√°s convendr√≠a plantearse contratar los servicios de una auditor√≠a de seguridad.

¬øAlguna de estas empresas querr√≠a patrocinarme esta entrada o el blog? üòè